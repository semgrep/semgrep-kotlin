(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_kotlin"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "equality_operator",
  Some (
    Alt [|
      Token (Literal "!=");
      Token (Literal "!==");
      Token (Literal "==");
      Token (Literal "===");
    |];
  );
  "parameter_modifier",
  Some (
    Alt [|
      Token (Literal "vararg");
      Token (Literal "noinline");
      Token (Literal "crossinline");
    |];
  );
  "pat_831065d", None;
  "as_operator",
  Some (
    Alt [|
      Token (Literal "as");
      Token (Literal "as?");
    |];
  );
  "integer_literal", None;
  "real_literal", None;
  "comparison_operator",
  Some (
    Alt [|
      Token (Literal "<");
      Token (Literal ">");
      Token (Literal "<=");
      Token (Literal ">=");
    |];
  );
  "variance_modifier",
  Some (
    Alt [|
      Token (Literal "in");
      Token (Literal "out");
    |];
  );
  "pat_f630af3", None;
  "bin_literal", None;
  "multiplicative_operator",
  Some (
    Alt [|
      Token (Literal "*");
      Token (Literal "/");
      Token (Literal "%");
    |];
  );
  "pat_b294348", None;
  "additive_operator",
  Some (
    Alt [|
      Token (Literal "+");
      Token (Literal "-");
    |];
  );
  "use_site_target",
  Some (
    Seq [
      Alt [|
        Token (Literal "field");
        Token (Literal "property");
        Token (Literal "get");
        Token (Literal "set");
        Token (Literal "receiver");
        Token (Literal "param");
        Token (Literal "setparam");
        Token (Literal "delegate");
      |];
      Token (Literal ":");
    ];
  );
  "hex_literal", None;
  "platform_modifier",
  Some (
    Alt [|
      Token (Literal "expect");
      Token (Literal "actual");
    |];
  );
  "boolean_literal",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "class_modifier",
  Some (
    Alt [|
      Token (Literal "sealed");
      Token (Literal "annotation");
      Token (Literal "data");
      Token (Literal "inner");
    |];
  );
  "reification_modifier", None;
  "label", None;
  "ellipsis", None;
  "pat_c793459", None;
  "property_modifier", None;
  "prefix_unary_operator",
  Some (
    Alt [|
      Token (Literal "++");
      Token (Literal "--");
      Token (Literal "-");
      Token (Literal "+");
      Token (Literal "!");
    |];
  );
  "automatic_semicolon", None;
  "in_operator",
  Some (
    Alt [|
      Token (Literal "in");
      Token (Literal "!in");
    |];
  );
  "quest", None;
  "postfix_unary_operator",
  Some (
    Alt [|
      Token (Literal "++");
      Token (Literal "--");
      Token (Literal "!!");
    |];
  );
  "this_expression", None;
  "function_modifier",
  Some (
    Alt [|
      Token (Literal "tailrec");
      Token (Literal "operator");
      Token (Literal "infix");
      Token (Literal "inline");
      Token (Literal "external");
      Token (Literal "suspend");
    |];
  );
  "pat_a2e2132", None;
  "safe_nav", None;
  "not_is", None;
  "super_expression",
  Some (
    Seq [
      Token (Literal "super");
    ];
  );
  "assignment_and_operator",
  Some (
    Alt [|
      Token (Literal "+=");
      Token (Literal "-=");
      Token (Literal "*=");
      Token (Literal "/=");
      Token (Literal "%=");
    |];
  );
  "member_modifier",
  Some (
    Alt [|
      Token (Literal "override");
      Token (Literal "lateinit");
    |];
  );
  "visibility_modifier",
  Some (
    Alt [|
      Token (Literal "public");
      Token (Literal "private");
      Token (Literal "internal");
      Token (Literal "protected");
    |];
  );
  "backtick_identifier", None;
  "line_str_text", None;
  "inheritance_modifier",
  Some (
    Alt [|
      Token (Literal "abstract");
      Token (Literal "final");
      Token (Literal "open");
    |];
  );
  "multi_line_str_text", None;
  "alpha_identifier", None;
  "escaped_identifier", None;
  "type_projection_modifier",
  Some (
    Token (Name "variance_modifier");
  );
  "shebang_line",
  Some (
    Seq [
      Token (Literal "#!");
      Token (Name "pat_f630af3");
    ];
  );
  "long_literal",
  Some (
    Seq [
      Alt [|
        Token (Name "integer_literal");
        Token (Name "hex_literal");
        Token (Name "bin_literal");
      |];
      Token (Literal "L");
    ];
  );
  "unsigned_literal",
  Some (
    Seq [
      Alt [|
        Token (Name "integer_literal");
        Token (Name "hex_literal");
        Token (Name "bin_literal");
      |];
      Token (Name "pat_c793459");
      Opt (
        Token (Literal "L");
      );
    ];
  );
  "semis",
  Some (
    Alt [|
      Token (Name "automatic_semicolon");
      Token (Literal ";");
    |];
  );
  "semi",
  Some (
    Alt [|
      Token (Name "automatic_semicolon");
      Token (Literal ";");
    |];
  );
  "uni_character_literal",
  Some (
    Seq [
      Token (Literal "\\u");
      Token (Name "pat_a2e2132");
    ];
  );
  "member_access_operator",
  Some (
    Alt [|
      Token (Literal ".");
      Token (Name "safe_nav");
      Token (Literal "::");
    |];
  );
  "is_operator",
  Some (
    Alt [|
      Token (Literal "is");
      Token (Name "not_is");
    |];
  );
  "modifier",
  Some (
    Alt [|
      Token (Name "class_modifier");
      Token (Name "member_modifier");
      Token (Name "visibility_modifier");
      Token (Name "function_modifier");
      Token (Name "property_modifier");
      Token (Name "inheritance_modifier");
      Token (Name "parameter_modifier");
      Token (Name "platform_modifier");
    |];
  );
  "multi_line_string_content",
  Some (
    Alt [|
      Token (Name "multi_line_str_text");
      Token (Literal "\"");
    |];
  );
  "lexical_identifier",
  Some (
    Alt [|
      Token (Name "alpha_identifier");
      Token (Name "backtick_identifier");
    |];
  );
  "type_projection_modifiers",
  Some (
    Repeat1 (
      Token (Name "type_projection_modifier");
    );
  );
  "escape_seq",
  Some (
    Alt [|
      Token (Name "uni_character_literal");
      Token (Name "escaped_identifier");
    |];
  );
  "line_str_escaped_char",
  Some (
    Alt [|
      Token (Name "escaped_identifier");
      Token (Name "uni_character_literal");
    |];
  );
  "simple_identifier",
  Some (
    Alt [|
      Alt [|
        Token (Name "lexical_identifier");
        Token (Literal "expect");
        Token (Literal "data");
        Token (Literal "inner");
        Token (Literal "actual");
      |];
      Token (Name "pat_831065d");
    |];
  );
  "continue_at",
  Some (
    Seq [
      Token (Literal "continue@");
      Token (Name "lexical_identifier");
    ];
  );
  "return_at",
  Some (
    Seq [
      Token (Literal "return@");
      Token (Name "lexical_identifier");
    ];
  );
  "break_at",
  Some (
    Seq [
      Token (Literal "break@");
      Token (Name "lexical_identifier");
    ];
  );
  "character_literal",
  Some (
    Seq [
      Token (Literal "'");
      Alt [|
        Token (Name "escape_seq");
        Token (Name "pat_b294348");
      |];
      Token (Literal "'");
    ];
  );
  "line_string_content",
  Some (
    Alt [|
      Token (Name "line_str_text");
      Token (Name "line_str_escaped_char");
    |];
  );
  "import_alias",
  Some (
    Seq [
      Token (Literal "as");
      Token (Name "simple_identifier");
    ];
  );
  "identifier",
  Some (
    Seq [
      Token (Name "simple_identifier");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "simple_identifier");
        ];
      );
    ];
  );
  "callable_reference",
  Some (
    Seq [
      Opt (
        Token (Name "simple_identifier");
      );
      Token (Literal "::");
      Alt [|
        Token (Name "simple_identifier");
        Token (Literal "class");
      |];
    ];
  );
  "literal_constant",
  Some (
    Alt [|
      Token (Name "boolean_literal");
      Token (Name "integer_literal");
      Token (Name "hex_literal");
      Token (Name "bin_literal");
      Token (Name "character_literal");
      Token (Name "real_literal");
      Token (Literal "null");
      Token (Name "long_literal");
      Token (Name "unsigned_literal");
    |];
  );
  "import_header",
  Some (
    Seq [
      Token (Literal "import");
      Token (Name "identifier");
      Opt (
        Alt [|
          Seq [
            Token (Literal ".*");
          ];
          Token (Name "import_alias");
        |];
      );
      Token (Name "semi");
    ];
  );
  "package_header",
  Some (
    Seq [
      Token (Literal "package");
      Token (Name "identifier");
      Token (Name "semi");
    ];
  );
  "additive_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "additive_operator");
      Token (Name "expression");
    ];
  );
  "annotated_lambda",
  Some (
    Seq [
      Repeat (
        Token (Name "annotation");
      );
      Opt (
        Token (Name "label");
      );
      Token (Name "lambda_literal");
    ];
  );
  "annotation",
  Some (
    Alt [|
      Token (Name "single_annotation");
      Token (Name "multi_annotation");
    |];
  );
  "anonymous_function",
  Some (
    Seq [
      Token (Literal "fun");
      Opt (
        Seq [
          Token (Name "simple_user_type");
          Repeat (
            Seq [
              Token (Literal ".");
              Token (Name "simple_user_type");
            ];
          );
          Token (Literal ".");
        ];
      );
      Token (Literal "(");
      Token (Literal ")");
      Opt (
        Token (Name "function_body");
      );
    ];
  );
  "anonymous_initializer",
  Some (
    Seq [
      Token (Literal "init");
      Token (Name "block");
    ];
  );
  "as_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "as_operator");
      Token (Name "type");
    ];
  );
  "assignment",
  Some (
    Alt [|
      Seq [
        Token (Name "directly_assignable_expression");
        Token (Name "assignment_and_operator");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "directly_assignable_expression");
        Token (Literal "=");
        Token (Name "expression");
      ];
    |];
  );
  "binary_expression",
  Some (
    Alt [|
      Token (Name "multiplicative_expression");
      Token (Name "additive_expression");
      Token (Name "range_expression");
      Token (Name "infix_expression");
      Token (Name "elvis_expression");
      Token (Name "check_expression");
      Token (Name "comparison_expression");
      Token (Name "equality_expression");
      Token (Name "conjunction_expression");
      Token (Name "disjunction_expression");
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Token (Name "statements");
      );
      Token (Literal "}");
    ];
  );
  "call_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "call_suffix");
    ];
  );
  "call_suffix",
  Some (
    Seq [
      Opt (
        Token (Name "type_arguments");
      );
      Alt [|
        Seq [
          Opt (
            Token (Name "value_arguments");
          );
          Token (Name "annotated_lambda");
        ];
        Token (Name "value_arguments");
      |];
    ];
  );
  "catch_block",
  Some (
    Seq [
      Token (Literal "catch");
      Token (Literal "(");
      Repeat (
        Token (Name "annotation");
      );
      Token (Name "simple_identifier");
      Token (Literal ":");
      Token (Name "type");
      Token (Literal ")");
      Token (Name "block");
    ];
  );
  "check_expression",
  Some (
    Seq [
      Token (Name "expression");
      Alt [|
        Seq [
          Token (Name "in_operator");
          Token (Name "expression");
        ];
        Seq [
          Token (Name "is_operator");
          Token (Name "type");
        ];
      |];
    ];
  );
  "class_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Token (Name "class_member_declarations");
      );
      Token (Literal "}");
    ];
  );
  "class_declaration",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Alt [|
          Token (Literal "class");
          Token (Literal "interface");
        |];
        Token (Name "simple_identifier");
        Opt (
          Token (Name "type_parameters");
        );
        Opt (
          Token (Name "primary_constructor");
        );
        Opt (
          Seq [
            Token (Literal ":");
            Token (Name "delegation_specifiers");
          ];
        );
        Opt (
          Token (Name "type_constraints");
        );
        Opt (
          Token (Name "class_body");
        );
      ];
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Token (Literal "enum");
        Token (Literal "class");
        Token (Name "simple_identifier");
        Opt (
          Token (Name "type_parameters");
        );
        Opt (
          Token (Name "primary_constructor");
        );
        Opt (
          Seq [
            Token (Literal ":");
            Token (Name "delegation_specifiers");
          ];
        );
        Opt (
          Token (Name "type_constraints");
        );
        Opt (
          Token (Name "enum_class_body");
        );
      ];
    |];
  );
  "class_member_declaration",
  Some (
    Alt [|
      Alt [|
        Token (Name "declaration");
        Token (Name "companion_object");
        Token (Name "anonymous_initializer");
        Token (Name "secondary_constructor");
      |];
      Token (Name "ellipsis");
    |];
  );
  "class_member_declarations",
  Some (
    Repeat1 (
      Seq [
        Token (Name "class_member_declaration");
        Token (Name "semis");
      ];
    );
  );
  "class_parameter",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Opt (
          Alt [|
            Token (Literal "val");
            Token (Literal "var");
          |];
        );
        Token (Name "simple_identifier");
        Token (Literal ":");
        Token (Name "type");
        Opt (
          Seq [
            Token (Literal "=");
            Token (Name "expression");
          ];
        );
      ];
      Token (Name "ellipsis");
    |];
  );
  "class_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "class_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "class_parameter");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "collection_literal",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Token (Literal "]");
    ];
  );
  "companion_object",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "companion");
      Token (Literal "object");
      Opt (
        Token (Name "simple_identifier");
      );
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "delegation_specifiers");
        ];
      );
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "comparison_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "comparison_operator");
      Token (Name "expression");
    ];
  );
  "conjunction_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "&&");
      Token (Name "expression");
    ];
  );
  "constructor_delegation_call",
  Some (
    Seq [
      Alt [|
        Token (Literal "this");
        Token (Literal "super");
      |];
      Token (Name "value_arguments");
    ];
  );
  "constructor_invocation",
  Some (
    Seq [
      Token (Name "user_type");
      Token (Name "value_arguments");
    ];
  );
  "control_structure_body",
  Some (
    Alt [|
      Token (Name "block");
      Token (Name "statement");
    |];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "class_declaration");
      Token (Name "object_declaration");
      Token (Name "function_declaration");
      Token (Name "property_declaration");
      Token (Name "getter");
      Token (Name "setter");
      Token (Name "type_alias");
    |];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "delegation_specifier",
  Some (
    Alt [|
      Token (Name "constructor_invocation");
      Token (Name "explicit_delegation");
      Token (Name "user_type");
      Token (Name "function_type");
    |];
  );
  "delegation_specifiers",
  Some (
    Seq [
      Token (Name "delegation_specifier");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "delegation_specifier");
        ];
      );
    ];
  );
  "directly_assignable_expression",
  Some (
    Alt [|
      Token (Name "postfix_unary_expression");
      Token (Name "simple_identifier");
    |];
  );
  "disjunction_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "||");
      Token (Name "expression");
    ];
  );
  "do_while_statement",
  Some (
    Seq [
      Token (Literal "do");
      Opt (
        Token (Name "control_structure_body");
      );
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "elvis_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?:");
      Token (Name "expression");
    ];
  );
  "enum_class_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Token (Name "enum_entries");
      );
      Opt (
        Seq [
          Token (Literal ";");
          Opt (
            Token (Name "class_member_declarations");
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "enum_entries",
  Some (
    Seq [
      Token (Name "enum_entry");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "enum_entry");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "enum_entry",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "simple_identifier");
      Opt (
        Token (Name "value_arguments");
      );
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "equality_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "equality_operator");
      Token (Name "expression");
    ];
  );
  "explicit_delegation",
  Some (
    Seq [
      Alt [|
        Token (Name "user_type");
        Token (Name "function_type");
      |];
      Token (Literal "by");
      Token (Name "expression");
    ];
  );
  "expression",
  Some (
    Alt [|
      Alt [|
        Token (Name "unary_expression");
        Token (Name "binary_expression");
        Token (Name "primary_expression");
      |];
      Token (Name "ellipsis");
      Token (Name "deep_ellipsis");
    |];
  );
  "finally_block",
  Some (
    Seq [
      Token (Literal "finally");
      Token (Name "block");
    ];
  );
  "for_statement",
  Some (
    Seq [
      Token (Literal "for");
      Token (Literal "(");
      Repeat (
        Token (Name "annotation");
      );
      Alt [|
        Token (Name "variable_declaration");
        Token (Name "multi_variable_declaration");
      |];
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal ")");
      Opt (
        Token (Name "control_structure_body");
      );
    ];
  );
  "function_body",
  Some (
    Alt [|
      Token (Name "block");
      Seq [
        Token (Literal "=");
        Token (Name "expression");
      ];
    |];
  );
  "function_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "fun");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Seq [
          Token (Name "receiver_type");
          Opt (
            Token (Literal ".");
          );
        ];
      );
      Token (Name "simple_identifier");
      Token (Name "function_value_parameters");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
      Opt (
        Token (Name "type_constraints");
      );
      Opt (
        Token (Name "function_body");
      );
    ];
  );
  "function_literal",
  Some (
    Alt [|
      Token (Name "lambda_literal");
      Token (Name "anonymous_function");
    |];
  );
  "function_type",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "simple_user_type");
          Token (Literal ".");
        ];
      );
      Token (Name "function_type_parameters");
      Token (Literal "->");
      Token (Name "type");
    ];
  );
  "function_type_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "parameter");
            Token (Name "type");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "parameter");
                Token (Name "type");
              |];
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "function_value_parameter",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "parameter_modifiers");
        );
        Token (Name "parameter");
        Opt (
          Seq [
            Token (Literal "=");
            Token (Name "expression");
          ];
        );
      ];
      Token (Name "ellipsis");
    |];
  );
  "function_value_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "function_value_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "function_value_parameter");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "getter",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "get");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Literal ")");
          Opt (
            Seq [
              Token (Literal ":");
              Token (Name "type");
            ];
          );
          Token (Name "function_body");
        ];
      );
    ];
  );
  "if_expression",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Alt [|
        Token (Name "control_structure_body");
        Token (Literal ";");
        Seq [
          Opt (
            Token (Name "control_structure_body");
          );
          Opt (
            Token (Literal ";");
          );
          Token (Literal "else");
          Alt [|
            Token (Name "control_structure_body");
            Token (Literal ";");
          |];
        ];
      |];
    ];
  );
  "indexing_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "indexing_suffix");
    ];
  );
  "indexing_suffix",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Token (Literal "]");
    ];
  );
  "infix_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "simple_identifier");
      Token (Name "expression");
    ];
  );
  "interpolation",
  Some (
    Alt [|
      Seq [
        Token (Literal "${");
        Token (Name "expression");
        Token (Literal "}");
      ];
      Seq [
        Token (Literal "$");
        Token (Name "simple_identifier");
      ];
    |];
  );
  "jump_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "throw");
        Token (Name "expression");
      ];
      Seq [
        Alt [|
          Token (Literal "return");
          Token (Name "return_at");
        |];
        Opt (
          Token (Name "expression");
        );
      ];
      Token (Literal "continue");
      Token (Name "continue_at");
      Token (Literal "break");
      Token (Name "break_at");
    |];
  );
  "lambda_literal",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Opt (
            Token (Name "lambda_parameters");
          );
          Token (Literal "->");
        ];
      );
      Opt (
        Token (Name "statements");
      );
      Token (Literal "}");
    ];
  );
  "lambda_parameter",
  Some (
    Alt [|
      Token (Name "variable_declaration");
      Token (Name "multi_variable_declaration");
    |];
  );
  "lambda_parameters",
  Some (
    Seq [
      Token (Name "lambda_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "lambda_parameter");
        ];
      );
    ];
  );
  "line_string_literal",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Token (Name "line_string_content");
          Token (Name "interpolation");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "loop_statement",
  Some (
    Alt [|
      Token (Name "for_statement");
      Token (Name "while_statement");
      Token (Name "do_while_statement");
    |];
  );
  "modifiers",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "annotation");
        Token (Name "modifier");
      |];
    );
  );
  "multi_annotation",
  Some (
    Seq [
      Token (Literal "@");
      Opt (
        Token (Name "use_site_target");
      );
      Token (Literal "[");
      Repeat1 (
        Token (Name "unescaped_annotation");
      );
      Token (Literal "]");
    ];
  );
  "multi_line_string_literal",
  Some (
    Seq [
      Token (Literal "\"\"\"");
      Repeat (
        Alt [|
          Token (Name "multi_line_string_content");
          Token (Name "interpolation");
        |];
      );
      Token (Literal "\"\"\"");
    ];
  );
  "multi_variable_declaration",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "variable_declaration");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_declaration");
        ];
      );
      Token (Literal ")");
    ];
  );
  "multiplicative_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "multiplicative_operator");
      Token (Name "expression");
    ];
  );
  "navigation_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "navigation_suffix");
    ];
  );
  "navigation_suffix",
  Some (
    Alt [|
      Seq [
        Token (Name "member_access_operator");
        Alt [|
          Token (Name "simple_identifier");
          Token (Name "parenthesized_expression");
          Token (Literal "class");
        |];
      ];
      Seq [
        Token (Name "member_access_operator");
        Token (Name "ellipsis");
      ];
    |];
  );
  "nullable_type",
  Some (
    Seq [
      Alt [|
        Token (Name "type_reference");
        Token (Name "parenthesized_type");
      |];
      Repeat1 (
        Token (Name "quest");
      );
    ];
  );
  "object_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "object");
      Token (Name "simple_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "delegation_specifiers");
        ];
      );
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "object_literal",
  Some (
    Seq [
      Token (Literal "object");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "delegation_specifiers");
        ];
      );
      Token (Name "class_body");
    ];
  );
  "parameter",
  Some (
    Seq [
      Token (Name "simple_identifier");
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "parameter_modifiers",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "annotation");
        Token (Name "parameter_modifier");
      |];
    );
  );
  "parameter_with_optional_type",
  Some (
    Seq [
      Opt (
        Token (Name "parameter_modifiers");
      );
      Token (Name "simple_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "parenthesized_type",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type");
      Token (Literal ")");
    ];
  );
  "postfix_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "postfix_unary_operator");
    ];
  );
  "postfix_unary_expression",
  Some (
    Seq [
      Token (Name "primary_expression");
      Repeat (
        Token (Name "postfix_unary_suffix");
      );
    ];
  );
  "postfix_unary_suffix",
  Some (
    Alt [|
      Token (Name "postfix_unary_operator");
      Token (Name "navigation_suffix");
      Token (Name "indexing_suffix");
    |];
  );
  "prefix_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "annotation");
        Token (Name "label");
        Token (Name "prefix_unary_operator");
      |];
      Token (Name "expression");
    ];
  );
  "primary_constructor",
  Some (
    Seq [
      Opt (
        Seq [
          Opt (
            Token (Name "modifiers");
          );
          Token (Literal "constructor");
        ];
      );
      Token (Name "class_parameters");
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Token (Name "parenthesized_expression");
      Token (Name "simple_identifier");
      Token (Name "literal_constant");
      Token (Name "string_literal");
      Token (Name "callable_reference");
      Token (Name "function_literal");
      Token (Name "object_literal");
      Token (Name "collection_literal");
      Token (Name "this_expression");
      Token (Name "super_expression");
      Token (Name "if_expression");
      Token (Name "when_expression");
      Token (Name "try_expression");
      Token (Name "jump_expression");
    |];
  );
  "property_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Alt [|
        Token (Literal "val");
        Token (Literal "var");
      |];
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Seq [
          Token (Name "receiver_type");
          Opt (
            Token (Literal ".");
          );
        ];
      );
      Alt [|
        Token (Name "variable_declaration");
        Token (Name "multi_variable_declaration");
      |];
      Opt (
        Token (Name "type_constraints");
      );
      Opt (
        Alt [|
          Seq [
            Token (Literal "=");
            Token (Name "expression");
          ];
          Token (Name "property_delegate");
        |];
      );
      Opt (
        Token (Literal ";");
      );
      Alt [|
        Opt (
          Token (Name "getter");
        );
        Opt (
          Token (Name "setter");
        );
      |];
    ];
  );
  "property_delegate",
  Some (
    Seq [
      Token (Literal "by");
      Token (Name "expression");
    ];
  );
  "range_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "..");
      Token (Name "expression");
    ];
  );
  "range_test",
  Some (
    Seq [
      Token (Name "in_operator");
      Token (Name "expression");
    ];
  );
  "receiver_type",
  Some (
    Seq [
      Opt (
        Token (Name "type_modifiers");
      );
      Alt [|
        Token (Name "type_reference");
        Token (Name "parenthesized_type");
        Token (Name "nullable_type");
      |];
    ];
  );
  "secondary_constructor",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "constructor");
      Token (Name "function_value_parameters");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "constructor_delegation_call");
        ];
      );
      Opt (
        Token (Name "block");
      );
    ];
  );
  "setter",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "set");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "parameter_with_optional_type");
          Token (Literal ")");
          Opt (
            Seq [
              Token (Literal ":");
              Token (Name "type");
            ];
          );
          Token (Name "function_body");
        ];
      );
    ];
  );
  "simple_user_type",
  Some (
    Seq [
      Token (Name "simple_identifier");
      Opt (
        Token (Name "type_arguments");
      );
    ];
  );
  "single_annotation",
  Some (
    Seq [
      Token (Literal "@");
      Opt (
        Token (Name "use_site_target");
      );
      Token (Name "unescaped_annotation");
    ];
  );
  "spread_expression",
  Some (
    Seq [
      Token (Literal "*");
      Token (Name "expression");
    ];
  );
  "statement",
  Some (
    Alt [|
      Token (Name "declaration");
      Seq [
        Repeat (
          Alt [|
            Token (Name "label");
            Token (Name "annotation");
          |];
        );
        Alt [|
          Token (Name "assignment");
          Token (Name "loop_statement");
          Token (Name "expression");
        |];
      ];
    |];
  );
  "statements",
  Some (
    Seq [
      Token (Name "statement");
      Repeat (
        Seq [
          Token (Name "semis");
          Token (Name "statement");
        ];
      );
      Opt (
        Token (Name "semis");
      );
    ];
  );
  "string_literal",
  Some (
    Alt [|
      Token (Name "line_string_literal");
      Token (Name "multi_line_string_literal");
    |];
  );
  "try_expression",
  Some (
    Seq [
      Token (Literal "try");
      Token (Name "block");
      Alt [|
        Seq [
          Repeat1 (
            Token (Name "catch_block");
          );
          Opt (
            Token (Name "finally_block");
          );
        ];
        Token (Name "finally_block");
      |];
    ];
  );
  "type",
  Some (
    Seq [
      Opt (
        Token (Name "type_modifiers");
      );
      Alt [|
        Token (Name "parenthesized_type");
        Token (Name "nullable_type");
        Token (Name "type_reference");
        Token (Name "function_type");
      |];
    ];
  );
  "type_alias",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Literal "typealias");
      Token (Name "simple_identifier");
      Token (Literal "=");
      Token (Name "type");
    ];
  );
  "type_arguments",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_projection");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_projection");
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_constraint",
  Some (
    Seq [
      Repeat (
        Token (Name "annotation");
      );
      Token (Name "simple_identifier");
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "type_constraints",
  Some (
    Seq [
      Token (Literal "where");
      Token (Name "type_constraint");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_constraint");
        ];
      );
    ];
  );
  "type_modifier",
  Some (
    Alt [|
      Token (Name "annotation");
      Token (Literal "suspend");
    |];
  );
  "type_modifiers",
  Some (
    Repeat1 (
      Token (Name "type_modifier");
    );
  );
  "type_parameter",
  Some (
    Seq [
      Opt (
        Token (Name "type_parameter_modifiers");
      );
      Token (Name "simple_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
    ];
  );
  "type_parameter_modifier",
  Some (
    Alt [|
      Token (Name "reification_modifier");
      Token (Name "variance_modifier");
      Token (Name "annotation");
    |];
  );
  "type_parameter_modifiers",
  Some (
    Repeat1 (
      Token (Name "type_parameter_modifier");
    );
  );
  "type_parameters",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_projection",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "type_projection_modifiers");
        );
        Token (Name "type");
      ];
      Token (Literal "*");
    |];
  );
  "type_reference",
  Some (
    Alt [|
      Token (Name "user_type");
      Token (Literal "dynamic");
    |];
  );
  "type_test",
  Some (
    Seq [
      Token (Name "is_operator");
      Token (Name "type");
    ];
  );
  "unary_expression",
  Some (
    Alt [|
      Token (Name "postfix_expression");
      Token (Name "call_expression");
      Token (Name "indexing_expression");
      Token (Name "navigation_expression");
      Token (Name "prefix_expression");
      Token (Name "as_expression");
      Token (Name "spread_expression");
    |];
  );
  "unescaped_annotation",
  Some (
    Alt [|
      Token (Name "constructor_invocation");
      Token (Name "user_type");
    |];
  );
  "user_type",
  Some (
    Seq [
      Token (Name "simple_user_type");
      Repeat (
        Seq [
          Token (Literal ".");
          Token (Name "simple_user_type");
        ];
      );
    ];
  );
  "value_argument",
  Some (
    Seq [
      Opt (
        Token (Name "annotation");
      );
      Opt (
        Seq [
          Token (Name "simple_identifier");
          Token (Literal "=");
        ];
      );
      Opt (
        Token (Literal "*");
      );
      Token (Name "expression");
    ];
  );
  "value_arguments",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "value_argument");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "value_argument");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "variable_declaration",
  Some (
    Seq [
      Token (Name "simple_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
    ];
  );
  "when_condition",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "range_test");
      Token (Name "type_test");
    |];
  );
  "when_entry",
  Some (
    Seq [
      Alt [|
        Seq [
          Token (Name "when_condition");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "when_condition");
            ];
          );
        ];
        Token (Literal "else");
      |];
      Token (Literal "->");
      Token (Name "control_structure_body");
      Opt (
        Token (Name "semi");
      );
    ];
  );
  "when_expression",
  Some (
    Seq [
      Token (Literal "when");
      Opt (
        Token (Name "when_subject");
      );
      Token (Literal "{");
      Repeat (
        Token (Name "when_entry");
      );
      Token (Literal "}");
    ];
  );
  "when_subject",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Repeat (
            Token (Name "annotation");
          );
          Token (Literal "val");
          Token (Name "variable_declaration");
          Token (Literal "=");
        ];
      );
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Alt [|
        Token (Literal ";");
        Token (Name "control_structure_body");
      |];
    ];
  );
  "file_annotation",
  Some (
    Seq [
      Token (Literal "@");
      Token (Literal "file");
      Token (Literal ":");
      Alt [|
        Seq [
          Token (Literal "[");
          Repeat1 (
            Token (Name "unescaped_annotation");
          );
          Token (Literal "]");
        ];
        Token (Name "unescaped_annotation");
      |];
      Token (Name "semi");
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Token (Name "expression");
    ];
  );
  "source_file",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "shebang_line");
        );
        Repeat (
          Token (Name "file_annotation");
        );
        Opt (
          Token (Name "package_header");
        );
        Repeat (
          Token (Name "import_header");
        );
        Repeat (
          Seq [
            Token (Name "statement");
            Token (Name "semi");
          ];
        );
      ];
      Token (Name "semgrep_expression");
    |];
  );
]

let trans_equality_operator ((kind, body) : mt) : CST.equality_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANGEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `BANGEQEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `EQEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `EQEQEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_parameter_modifier ((kind, body) : mt) : CST.parameter_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Vararg (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Noin (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Cros (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_831065d ((kind, body) : mt) : CST.pat_831065d =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_as_operator ((kind, body) : mt) : CST.as_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `As (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `AsQM (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_integer_literal ((kind, body) : mt) : CST.integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_real_literal ((kind, body) : mt) : CST.real_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_comparison_operator ((kind, body) : mt) : CST.comparison_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variance_modifier ((kind, body) : mt) : CST.variance_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `In (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Out (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_f630af3 ((kind, body) : mt) : CST.pat_f630af3 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bin_literal ((kind, body) : mt) : CST.bin_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_multiplicative_operator ((kind, body) : mt) : CST.multiplicative_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SLASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `PERC (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_b294348 ((kind, body) : mt) : CST.pat_b294348 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_additive_operator ((kind, body) : mt) : CST.additive_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_site_target ((kind, body) : mt) : CST.use_site_target =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Field (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Prop (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Get (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Set (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Rece (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Param (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Setp (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Dele (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_hex_literal ((kind, body) : mt) : CST.hex_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_platform_modifier ((kind, body) : mt) : CST.platform_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Expect (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Actual (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_boolean_literal ((kind, body) : mt) : CST.boolean_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_class_modifier ((kind, body) : mt) : CST.class_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Sealed (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anno (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Data (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Inner (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_reification_modifier ((kind, body) : mt) : CST.reification_modifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_label ((kind, body) : mt) : CST.label =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_c793459 ((kind, body) : mt) : CST.pat_c793459 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_property_modifier ((kind, body) : mt) : CST.property_modifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_prefix_unary_operator ((kind, body) : mt) : CST.prefix_unary_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUSPLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASHDASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `DASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `PLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `BANG (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_automatic_semicolon ((kind, body) : mt) : CST.automatic_semicolon =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_in_operator ((kind, body) : mt) : CST.in_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `In (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `BANGin (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_quest ((kind, body) : mt) : CST.quest =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_postfix_unary_operator ((kind, body) : mt) : CST.postfix_unary_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUSPLUS (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASHDASH (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `BANGBANG (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_this_expression ((kind, body) : mt) : CST.this_expression =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_function_modifier ((kind, body) : mt) : CST.function_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tail (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Op (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Infix (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Inline (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Exte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Susp (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_a2e2132 ((kind, body) : mt) : CST.pat_a2e2132 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_safe_nav ((kind, body) : mt) : CST.safe_nav =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_not_is ((kind, body) : mt) : CST.not_is =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_super_expression ((kind, body) : mt) : CST.super_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (Run.trans_token (Run.matcher_token v0))
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_assignment_and_operator ((kind, body) : mt) : CST.assignment_and_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUSEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `STAREQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `SLASHEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `PERCEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_member_modifier ((kind, body) : mt) : CST.member_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Over (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Late (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_visibility_modifier ((kind, body) : mt) : CST.visibility_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Public (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Priv (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inte (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Prot (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_backtick_identifier ((kind, body) : mt) : CST.backtick_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_line_str_text ((kind, body) : mt) : CST.line_str_text =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_inheritance_modifier ((kind, body) : mt) : CST.inheritance_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Abst (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Final (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Open (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_multi_line_str_text ((kind, body) : mt) : CST.multi_line_str_text =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_alpha_identifier ((kind, body) : mt) : CST.alpha_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escaped_identifier ((kind, body) : mt) : CST.escaped_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_type_projection_modifier ((kind, body) : mt) : CST.type_projection_modifier =
  match body with
  | Children v ->
      trans_variance_modifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_shebang_line ((kind, body) : mt) : CST.shebang_line =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_f630af3 (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_long_literal ((kind, body) : mt) : CST.long_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Int_lit (
                  trans_integer_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Hex_lit (
                  trans_hex_literal (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Bin_lit (
                  trans_bin_literal (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_unsigned_literal ((kind, body) : mt) : CST.unsigned_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Int_lit (
                  trans_integer_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Hex_lit (
                  trans_hex_literal (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Bin_lit (
                  trans_bin_literal (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_pat_c793459 (Run.matcher_token v1),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semis ((kind, body) : mt) : CST.semis =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Auto_semi (
            trans_automatic_semicolon (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semi ((kind, body) : mt) : CST.semi =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Auto_semi (
            trans_automatic_semicolon (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `SEMI (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_uni_character_literal ((kind, body) : mt) : CST.uni_character_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_a2e2132 (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_member_access_operator ((kind, body) : mt) : CST.member_access_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Safe_nav (
            trans_safe_nav (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `COLONCOLON (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_is_operator ((kind, body) : mt) : CST.is_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Is (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Not_is (
            trans_not_is (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_modifier ((kind, body) : mt) : CST.modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Class_modi (
            trans_class_modifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Member_modi (
            trans_member_modifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Visi_modi (
            trans_visibility_modifier (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Func_modi (
            trans_function_modifier (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Prop_modi (
            trans_property_modifier (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Inhe_modi (
            trans_inheritance_modifier (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Param_modi (
            trans_parameter_modifier (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Plat_modi (
            trans_platform_modifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_multi_line_string_content ((kind, body) : mt) : CST.multi_line_string_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Multi_line_str_text (
            trans_multi_line_str_text (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `DQUOT (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_lexical_identifier ((kind, body) : mt) : CST.lexical_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Alpha_id (
            trans_alpha_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Back_id (
            trans_backtick_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_projection_modifiers ((kind, body) : mt) : CST.type_projection_modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          trans_type_projection_modifier (Run.matcher_token v)
        )
        v
  | Leaf _ -> assert false

let trans_escape_seq ((kind, body) : mt) : CST.escape_seq =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Uni_char_lit (
            trans_uni_character_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Esca_id (
            trans_escaped_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_line_str_escaped_char ((kind, body) : mt) : CST.line_str_escaped_char =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Esca_id (
            trans_escaped_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Uni_char_lit (
            trans_uni_character_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_simple_identifier ((kind, body) : mt) : CST.simple_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_lexi_id (
            (match v with
            | Alt (0, v) ->
                `Lexi_id (
                  trans_lexical_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Expect (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Data (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Inner (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Actual (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Pat_831065d (
            trans_pat_831065d (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_at ((kind, body) : mt) : CST.continue_at =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_lexical_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_return_at ((kind, body) : mt) : CST.return_at =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_lexical_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_break_at ((kind, body) : mt) : CST.break_at =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_lexical_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_character_literal ((kind, body) : mt) : CST.character_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Esc_seq (
                  trans_escape_seq (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_b294348 (
                  trans_pat_b294348 (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_line_string_content ((kind, body) : mt) : CST.line_string_content =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Line_str_text (
            trans_line_str_text (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Line_str_esca_char (
            trans_line_str_escaped_char (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_alias ((kind, body) : mt) : CST.import_alias =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_simple_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_simple_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_simple_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_callable_reference ((kind, body) : mt) : CST.callable_reference =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_simple_identifier (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Simple_id (
                  trans_simple_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Class (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal_constant ((kind, body) : mt) : CST.literal_constant =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bool_lit (
            trans_boolean_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Int_lit (
            trans_integer_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Hex_lit (
            trans_hex_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Bin_lit (
            trans_bin_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Char_lit (
            trans_character_literal (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Real_lit (
            trans_real_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Null (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Long_lit (
            trans_long_literal (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Unsi_lit (
            trans_unsigned_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_import_header ((kind, body) : mt) : CST.import_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `DOTSTAR (
                      (match v with
                      | Seq [v0] ->
                          (Run.trans_token (Run.matcher_token v0))
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Import_alias (
                      trans_import_alias (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            trans_semi (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_package_header ((kind, body) : mt) : CST.package_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_semi (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_additive_expression ((kind, body) : mt) : CST.additive_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_additive_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotated_lambda ((kind, body) : mt) : CST.annotated_lambda =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_label (Run.matcher_token v))
              v1
            ,
            trans_lambda_literal (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Single_anno (
            trans_single_annotation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Multi_anno (
            trans_multi_annotation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_anonymous_function ((kind, body) : mt) : CST.anonymous_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2] ->
                    (
                      trans_simple_user_type (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_simple_user_type (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                      ,
                      Run.trans_token (Run.matcher_token v2)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_function_body (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_anonymous_initializer ((kind, body) : mt) : CST.anonymous_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_as_expression ((kind, body) : mt) : CST.as_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_as_operator (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment ((kind, body) : mt) : CST.assignment =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Dire_assi_exp_assign_and_op_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_directly_assignable_expression (Run.matcher_token v0),
                  trans_assignment_and_operator (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Dire_assi_exp_EQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_directly_assignable_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Mult_exp (
            trans_multiplicative_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Addi_exp (
            trans_additive_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Range_exp (
            trans_range_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Infix_exp (
            trans_infix_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Elvis_exp (
            trans_elvis_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Check_exp (
            trans_check_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Comp_exp (
            trans_comparison_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Equa_exp (
            trans_equality_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Conj_exp (
            trans_conjunction_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Disj_exp (
            trans_disjunction_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_statements (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expression ((kind, body) : mt) : CST.call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_call_suffix (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_suffix ((kind, body) : mt) : CST.call_suffix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Opt_value_args_anno_lambda (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> trans_value_arguments (Run.matcher_token v))
                          v0
                        ,
                        trans_annotated_lambda (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Value_args (
                  trans_value_arguments (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_block ((kind, body) : mt) : CST.catch_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v2
            ,
            trans_simple_identifier (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_type_ (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6),
            trans_block (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_check_expression ((kind, body) : mt) : CST.check_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `In_op_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_in_operator (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Is_op_type (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_is_operator (Run.matcher_token v0),
                        trans_type_ (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                trans_class_member_declarations (Run.matcher_token v)
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_declaration ((kind, body) : mt) : CST.class_declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_modifs_choice_class_simple_id_opt_type_params_opt_prim_cons_opt_COLON_dele_specis_opt_type_consts_opt_class_body (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Class (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Inte (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_simple_identifier (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v3
                  ,
                  Run.opt
                    (fun v -> trans_primary_constructor (Run.matcher_token v))
                    v4
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_delegation_specifiers (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v5
                  ,
                  Run.opt
                    (fun v -> trans_type_constraints (Run.matcher_token v))
                    v6
                  ,
                  Run.opt
                    (fun v -> trans_class_body (Run.matcher_token v))
                    v7
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Opt_modifs_enum_class_simple_id_opt_type_params_opt_prim_cons_opt_COLON_dele_specis_opt_type_consts_opt_enum_class_body (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_simple_identifier (Run.matcher_token v3),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v4
                  ,
                  Run.opt
                    (fun v -> trans_primary_constructor (Run.matcher_token v))
                    v5
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_delegation_specifiers (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v6
                  ,
                  Run.opt
                    (fun v -> trans_type_constraints (Run.matcher_token v))
                    v7
                  ,
                  Run.opt
                    (fun v -> trans_enum_class_body (Run.matcher_token v))
                    v8
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_member_declaration ((kind, body) : mt) : CST.class_member_declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_decl (
            (match v with
            | Alt (0, v) ->
                `Decl (
                  trans_declaration (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Comp_obj (
                  trans_companion_object (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Anon_init (
                  trans_anonymous_initializer (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Seco_cons (
                  trans_secondary_constructor (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_member_declarations ((kind, body) : mt) : CST.class_member_declarations =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1] ->
              (
                trans_class_member_declaration (Run.matcher_token v0),
                trans_semis (Run.matcher_token v1)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_class_parameter ((kind, body) : mt) : CST.class_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_modifs_opt_choice_val_simple_id_COLON_type_opt_EQ_exp (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  Run.opt
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Val (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Var (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  trans_simple_identifier (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_type_ (Run.matcher_token v4),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v5
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_parameters ((kind, body) : mt) : CST.class_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_class_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_class_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_collection_literal ((kind, body) : mt) : CST.collection_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_companion_object ((kind, body) : mt) : CST.companion_object =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_simple_identifier (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_delegation_specifiers (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comparison_expression ((kind, body) : mt) : CST.comparison_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_comparison_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conjunction_expression ((kind, body) : mt) : CST.conjunction_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_delegation_call ((kind, body) : mt) : CST.constructor_delegation_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `This (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Super (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_value_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_invocation ((kind, body) : mt) : CST.constructor_invocation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_user_type (Run.matcher_token v0),
            trans_value_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_control_structure_body ((kind, body) : mt) : CST.control_structure_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Stmt (
            trans_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Class_decl (
            trans_class_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Obj_decl (
            trans_object_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Func_decl (
            trans_function_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Prop_decl (
            trans_property_declaration (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Getter (
            trans_getter (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Setter (
            trans_setter (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Type_alias (
            trans_type_alias (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_delegation_specifier ((kind, body) : mt) : CST.delegation_specifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cons_invo (
            trans_constructor_invocation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Expl_dele (
            trans_explicit_delegation (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `User_type (
            trans_user_type (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Func_type (
            trans_function_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_delegation_specifiers ((kind, body) : mt) : CST.delegation_specifiers =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_delegation_specifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_delegation_specifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_directly_assignable_expression ((kind, body) : mt) : CST.directly_assignable_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Post_un_exp (
            trans_postfix_unary_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Simple_id (
            trans_simple_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_disjunction_expression ((kind, body) : mt) : CST.disjunction_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_while_statement ((kind, body) : mt) : CST.do_while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                trans_control_structure_body (Run.matcher_token v)
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_elvis_expression ((kind, body) : mt) : CST.elvis_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_class_body ((kind, body) : mt) : CST.enum_class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_enum_entries (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.opt
                        (fun v ->
                          trans_class_member_declarations (Run.matcher_token v)
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_entries ((kind, body) : mt) : CST.enum_entries =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_enum_entry (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_enum_entry (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_entry ((kind, body) : mt) : CST.enum_entry =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_simple_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_value_arguments (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_equality_expression ((kind, body) : mt) : CST.equality_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_equality_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_explicit_delegation ((kind, body) : mt) : CST.explicit_delegation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `User_type (
                  trans_user_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Func_type (
                  trans_function_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_un_exp (
            (match v with
            | Alt (0, v) ->
                `Un_exp (
                  trans_unary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bin_exp (
                  trans_binary_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_block ((kind, body) : mt) : CST.finally_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v2
            ,
            (match v3 with
            | Alt (0, v) ->
                `Var_decl (
                  trans_variable_declaration (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Multi_var_decl (
                  trans_multi_variable_declaration (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v4),
            trans_expression (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6),
            Run.opt
              (fun v ->
                trans_control_structure_body (Run.matcher_token v)
              )
              v7
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `EQ_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_declaration ((kind, body) : mt) : CST.function_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_receiver_type (Run.matcher_token v0),
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            trans_simple_identifier (Run.matcher_token v4),
            trans_function_value_parameters (Run.matcher_token v5),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.opt
              (fun v -> trans_type_constraints (Run.matcher_token v))
              v7
            ,
            Run.opt
              (fun v -> trans_function_body (Run.matcher_token v))
              v8
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_literal ((kind, body) : mt) : CST.function_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lambda_lit (
            trans_lambda_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anon_func (
            trans_anonymous_function (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type ((kind, body) : mt) : CST.function_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_simple_user_type (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_function_type_parameters (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type_parameters ((kind, body) : mt) : CST.function_type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Param (
                            trans_parameter (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Type (
                            trans_type_ (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Param (
                                      trans_parameter (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Type (
                                      trans_type_ (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_value_parameter ((kind, body) : mt) : CST.function_value_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_param_modifs_param_opt_EQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_parameter_modifiers (Run.matcher_token v))
                    v0
                  ,
                  trans_parameter (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Ellips (
            trans_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_value_parameters ((kind, body) : mt) : CST.function_value_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_function_value_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_function_value_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_getter ((kind, body) : mt) : CST.getter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type_ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      trans_function_body (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_expression ((kind, body) : mt) : CST.if_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `Cont_stru_body (
                  trans_control_structure_body (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Opt_cont_stru_body_opt_SEMI_else_choice_cont_stru_body (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.opt
                          (fun v ->
                            trans_control_structure_body (Run.matcher_token v)
                          )
                          v0
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2),
                        (match v3 with
                        | Alt (0, v) ->
                            `Cont_stru_body (
                              trans_control_structure_body (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `SEMI (
                              Run.trans_token (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_indexing_expression ((kind, body) : mt) : CST.indexing_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_indexing_suffix (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_indexing_suffix ((kind, body) : mt) : CST.indexing_suffix =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_infix_expression ((kind, body) : mt) : CST.infix_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_simple_identifier (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interpolation ((kind, body) : mt) : CST.interpolation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOLLARLCURL_exp_RCURL (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DOLLAR_simple_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_simple_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_jump_expression ((kind, body) : mt) : CST.jump_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Throw_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_ret_opt_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Ret (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Ret_at (
                        trans_return_at (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.opt
                    (fun v -> trans_expression (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Cont (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Cont_at (
            trans_continue_at (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Brk (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Brk_at (
            trans_break_at (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_literal ((kind, body) : mt) : CST.lambda_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_lambda_parameters (Run.matcher_token v))
                        v0
                      ,
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_statements (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_parameter ((kind, body) : mt) : CST.lambda_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Var_decl (
            trans_variable_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Multi_var_decl (
            trans_multi_variable_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_parameters ((kind, body) : mt) : CST.lambda_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_lambda_parameter (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_lambda_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_line_string_literal ((kind, body) : mt) : CST.line_string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Line_str_content (
                      trans_line_string_content (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Interp (
                      trans_interpolation (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_loop_statement ((kind, body) : mt) : CST.loop_statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For_stmt (
            trans_for_statement (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `While_stmt (
            trans_while_statement (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Do_while_stmt (
            trans_do_while_statement (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_modifiers ((kind, body) : mt) : CST.modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Anno (
                trans_annotation (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Modi (
                trans_modifier (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_multi_annotation ((kind, body) : mt) : CST.multi_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_use_site_target (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.repeat1
              (fun v -> trans_unescaped_annotation (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_multi_line_string_literal ((kind, body) : mt) : CST.multi_line_string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Multi_line_str_content (
                      trans_multi_line_string_content (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Interp (
                      trans_interpolation (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_multi_variable_declaration ((kind, body) : mt) : CST.multi_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_variable_declaration (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_declaration (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_multiplicative_expression ((kind, body) : mt) : CST.multiplicative_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_multiplicative_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_navigation_expression ((kind, body) : mt) : CST.navigation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_navigation_suffix (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_navigation_suffix ((kind, body) : mt) : CST.navigation_suffix =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Member_access_op_choice_simple_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_member_access_operator (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `Simple_id (
                        trans_simple_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Paren_exp (
                        trans_parenthesized_expression (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Class (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Member_access_op_ellips (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_member_access_operator (Run.matcher_token v0),
                  trans_ellipsis (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_nullable_type ((kind, body) : mt) : CST.nullable_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Type_ref (
                  trans_type_reference (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Paren_type (
                  trans_parenthesized_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat1
              (fun v -> trans_quest (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_declaration ((kind, body) : mt) : CST.object_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_simple_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_delegation_specifiers (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_literal ((kind, body) : mt) : CST.object_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_delegation_specifiers (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_class_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter ((kind, body) : mt) : CST.parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_simple_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parameter_modifiers ((kind, body) : mt) : CST.parameter_modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Anno (
                trans_annotation (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Param_modi (
                trans_parameter_modifier (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_parameter_with_optional_type ((kind, body) : mt) : CST.parameter_with_optional_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_parameter_modifiers (Run.matcher_token v))
              v0
            ,
            trans_simple_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_type ((kind, body) : mt) : CST.parenthesized_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_expression ((kind, body) : mt) : CST.postfix_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_postfix_unary_operator (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_unary_expression ((kind, body) : mt) : CST.postfix_unary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_postfix_unary_suffix (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_postfix_unary_suffix ((kind, body) : mt) : CST.postfix_unary_suffix =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Post_un_op (
            trans_postfix_unary_operator (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Navi_suffix (
            trans_navigation_suffix (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inde_suffix (
            trans_indexing_suffix (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_prefix_expression ((kind, body) : mt) : CST.prefix_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Anno (
                  trans_annotation (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Label (
                  trans_label (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Prefix_un_op (
                  trans_prefix_unary_operator (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_constructor ((kind, body) : mt) : CST.primary_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_modifiers (Run.matcher_token v))
                        v0
                      ,
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_class_parameters (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Paren_exp (
            trans_parenthesized_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Simple_id (
            trans_simple_identifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Lit_cst (
            trans_literal_constant (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Call_ref (
            trans_callable_reference (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Func_lit (
            trans_function_literal (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Obj_lit (
            trans_object_literal (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Coll_lit (
            trans_collection_literal (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `This_exp (
            trans_this_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Super_exp (
            trans_super_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `If_exp (
            trans_if_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `When_exp (
            trans_when_expression (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Try_exp (
            trans_try_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Jump_exp (
            trans_jump_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_property_declaration ((kind, body) : mt) : CST.property_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Val (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Var (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_receiver_type (Run.matcher_token v0),
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            (match v4 with
            | Alt (0, v) ->
                `Var_decl (
                  trans_variable_declaration (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Multi_var_decl (
                  trans_multi_variable_declaration (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_type_constraints (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `EQ_exp (
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                | Alt (1, v) ->
                    `Prop_dele (
                      trans_property_delegate (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v7
            ,
            (match v8 with
            | Alt (0, v) ->
                `Opt_getter (
                  Run.opt
                    (fun v -> trans_getter (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `Opt_setter (
                  Run.opt
                    (fun v -> trans_setter (Run.matcher_token v))
                    v
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_property_delegate ((kind, body) : mt) : CST.property_delegate =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range_expression ((kind, body) : mt) : CST.range_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_range_test ((kind, body) : mt) : CST.range_test =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_in_operator (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_receiver_type ((kind, body) : mt) : CST.receiver_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_type_modifiers (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Type_ref (
                  trans_type_reference (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Paren_type (
                  trans_parenthesized_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Null_type (
                  trans_nullable_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_secondary_constructor ((kind, body) : mt) : CST.secondary_constructor =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_function_value_parameters (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_constructor_delegation_call (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> trans_block (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_setter ((kind, body) : mt) : CST.setter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_parameter_with_optional_type (Run.matcher_token v1),
                      Run.trans_token (Run.matcher_token v2),
                      Run.opt
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type_ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v3
                      ,
                      trans_function_body (Run.matcher_token v4)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_simple_user_type ((kind, body) : mt) : CST.simple_user_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_simple_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_single_annotation ((kind, body) : mt) : CST.single_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_use_site_target (Run.matcher_token v))
              v1
            ,
            trans_unescaped_annotation (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spread_expression ((kind, body) : mt) : CST.spread_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Decl (
            trans_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep_choice_label_choice_assign (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Alt (0, v) ->
                          `Label (
                            trans_label (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Anno (
                            trans_annotation (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                    v0
                  ,
                  (match v1 with
                  | Alt (0, v) ->
                      `Assign (
                        trans_assignment (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Loop_stmt (
                        trans_loop_statement (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `Exp (
                        trans_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statements ((kind, body) : mt) : CST.statements =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_statement (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_semis (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_semis (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Line_str_lit (
            trans_line_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Multi_line_str_lit (
            trans_multi_line_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_expression ((kind, body) : mt) : CST.try_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Rep1_catch_blk_opt_fina_blk (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v -> trans_catch_block (Run.matcher_token v))
                          v0
                        ,
                        Run.opt
                          (fun v -> trans_finally_block (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Fina_blk (
                  trans_finally_block (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_type_modifiers (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Paren_type (
                  trans_parenthesized_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Null_type (
                  trans_nullable_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Type_ref (
                  trans_type_reference (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Func_type (
                  trans_function_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_alias ((kind, body) : mt) : CST.type_alias =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_simple_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_type_ (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_projection (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_projection (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_constraint ((kind, body) : mt) : CST.type_constraint =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            trans_simple_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_constraints ((kind, body) : mt) : CST.type_constraints =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_constraint (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_constraint (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_modifier ((kind, body) : mt) : CST.type_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Anno (
            trans_annotation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Susp (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_modifiers ((kind, body) : mt) : CST.type_modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v -> trans_type_modifier (Run.matcher_token v))
        v
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v ->
                trans_type_parameter_modifiers (Run.matcher_token v)
              )
              v0
            ,
            trans_simple_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_modifier ((kind, body) : mt) : CST.type_parameter_modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Reif_modi (
            trans_reification_modifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Vari_modi (
            trans_variance_modifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Anno (
            trans_annotation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter_modifiers ((kind, body) : mt) : CST.type_parameter_modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          trans_type_parameter_modifier (Run.matcher_token v)
        )
        v
  | Leaf _ -> assert false

and trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_projection ((kind, body) : mt) : CST.type_projection =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_type_proj_modifs_type (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v ->
                      trans_type_projection_modifiers (Run.matcher_token v)
                    )
                    v0
                  ,
                  trans_type_ (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `STAR (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_reference ((kind, body) : mt) : CST.type_reference =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `User_type (
            trans_user_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Dyna (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_test ((kind, body) : mt) : CST.type_test =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_is_operator (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Post_exp (
            trans_postfix_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Call_exp (
            trans_call_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inde_exp (
            trans_indexing_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Navi_exp (
            trans_navigation_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Prefix_exp (
            trans_prefix_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `As_exp (
            trans_as_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Spread_exp (
            trans_spread_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unescaped_annotation ((kind, body) : mt) : CST.unescaped_annotation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Cons_invo (
            trans_constructor_invocation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `User_type (
            trans_user_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_user_type ((kind, body) : mt) : CST.user_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_simple_user_type (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_simple_user_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_value_argument ((kind, body) : mt) : CST.value_argument =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_simple_identifier (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_value_arguments ((kind, body) : mt) : CST.value_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_value_argument (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_value_argument (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declaration ((kind, body) : mt) : CST.variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_simple_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_when_condition ((kind, body) : mt) : CST.when_condition =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Range_test (
            trans_range_test (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Type_test (
            trans_type_test (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_when_entry ((kind, body) : mt) : CST.when_entry =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `When_cond_rep_COMMA_when_cond (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_when_condition (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_when_condition (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Else (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_control_structure_body (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_semi (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_when_expression ((kind, body) : mt) : CST.when_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_when_subject (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            Run.repeat
              (fun v -> trans_when_entry (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_when_subject ((kind, body) : mt) : CST.when_subject =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.repeat
                        (fun v -> trans_annotation (Run.matcher_token v))
                        v0
                      ,
                      Run.trans_token (Run.matcher_token v1),
                      trans_variable_declaration (Run.matcher_token v2),
                      Run.trans_token (Run.matcher_token v3)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            (match v4 with
            | Alt (0, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Cont_stru_body (
                  trans_control_structure_body (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_file_annotation ((kind, body) : mt) : CST.file_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `LBRACK_rep1_unes_anno_RBRACK (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.repeat1
                          (fun v -> trans_unescaped_annotation (Run.matcher_token v))
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Unes_anno (
                  trans_unescaped_annotation (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_semi (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false





let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_sheb_line_rep_file_anno_opt_pack_header_rep_import_header_rep_stmt_semi (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  Run.opt
                    (fun v -> trans_shebang_line (Run.matcher_token v))
                    v0
                  ,
                  Run.repeat
                    (fun v -> trans_file_annotation (Run.matcher_token v))
                    v1
                  ,
                  Run.opt
                    (fun v -> trans_package_header (Run.matcher_token v))
                    v2
                  ,
                  Run.repeat
                    (fun v -> trans_import_header (Run.matcher_token v))
                    v3
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_statement (Run.matcher_token v0),
                            trans_semi (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_source_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

