(* Generated by ocaml-tree-sitter. *)
(*
   kotlin grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type equality_operator = [
    `BANGEQ of Token.t (* "!=" *)
  | `BANGEQEQ of Token.t (* "!==" *)
  | `EQEQ of Token.t (* "==" *)
  | `EQEQEQ of Token.t (* "===" *)
]
[@@deriving sexp_of]

type pat_831065d = Token.t (* pattern \$[a-zA-Z_][a-zA-Z_0-9]* *)
[@@deriving sexp_of]

type pat_b294348 = Token.t (* pattern "[^\\n\\r'\\\\]" *)
[@@deriving sexp_of]

type semi = Token.t (* pattern [\r\n]+ *)
[@@deriving sexp_of]

type anon_choice_val_2833752 = [
    `Val of Token.t (* "val" *)
  | `Var of Token.t (* "var" *)
]
[@@deriving sexp_of]

type pat_ddcb2a5 = Token.t (* pattern [a-zA-Z_][a-zA-Z_0-9]* *)
[@@deriving sexp_of]

type real_literal = Token.t
[@@deriving sexp_of]

type comparison_operator = [
    `LT of Token.t (* "<" *)
  | `GT of Token.t (* ">" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GTEQ of Token.t (* ">=" *)
]
[@@deriving sexp_of]

type prefix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
  | `BANG of Token.t (* "!" *)
]
[@@deriving sexp_of]

type assignment_and_operator = [
    `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
]
[@@deriving sexp_of]

type variance_modifier = [
    `In of Token.t (* "in" *)
  | `Out of Token.t (* "out" *)
]
[@@deriving sexp_of]

type in_operator = [
    `In of Token.t (* "in" *)
  | `BANGin of Token.t (* "!in" *)
]
[@@deriving sexp_of]

type pat_f630af3 = Token.t (* pattern [^\r\n]* *)
[@@deriving sexp_of]

type label = Token.t
[@@deriving sexp_of]

type class_modifier = [
    `Sealed of Token.t (* "sealed" *)
  | `Anno of Token.t (* "annotation" *)
  | `Data of Token.t (* "data" *)
  | `Inner of Token.t (* "inner" *)
]
[@@deriving sexp_of]

type postfix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `BANGBANG of Token.t (* "!!" *)
]
[@@deriving sexp_of]

type line_str_text = Token.t (* pattern "[^\\\\\"$]+" *)
[@@deriving sexp_of]

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]
[@@deriving sexp_of]

type function_modifier = [
    `Tail of Token.t (* "tailrec" *)
  | `Op of Token.t (* "operator" *)
  | `Infix of Token.t (* "infix" *)
  | `Inline of Token.t (* "inline" *)
  | `Exte of Token.t (* "external" *)
  | `Susp of Token.t (* "suspend" *)
]
[@@deriving sexp_of]

type pat_c793459 = Token.t (* pattern [uU] *)
[@@deriving sexp_of]

type additive_operator = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
]
[@@deriving sexp_of]

type use_site_target = (
    [
        `Field of Token.t (* "field" *)
      | `Prop of Token.t (* "property" *)
      | `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Rece of Token.t (* "receiver" *)
      | `Param of Token.t (* "param" *)
      | `Setp of Token.t (* "setparam" *)
      | `Dele of Token.t (* "delegate" *)
    ]
  * Token.t (* ":" *)
)
[@@deriving sexp_of]

type inheritance_modifier = [
    `Abst of Token.t (* "abstract" *)
  | `Final of Token.t (* "final" *)
  | `Open of Token.t (* "open" *)
]
[@@deriving sexp_of]

type pat_b9a3713 = Token.t (* pattern `[^\r\n`]+` *)
[@@deriving sexp_of]

type hex_literal = Token.t
[@@deriving sexp_of]

type parameter_modifier = [
    `Vararg of Token.t (* "vararg" *)
  | `Noin of Token.t (* "noinline" *)
  | `Cros of Token.t (* "crossinline" *)
]
[@@deriving sexp_of]

type as_operator = [
    `As of Token.t (* "as" *)
  | `AsQM of Token.t (* "as?" *)
]
[@@deriving sexp_of]

type platform_modifier = [
    `Expect of Token.t (* "expect" *)
  | `Actual of Token.t (* "actual" *)
]
[@@deriving sexp_of]

type semis = Token.t (* pattern [\r\n]+ *)
[@@deriving sexp_of]

type multi_line_str_text = Token.t (* pattern "[^\"$]+" *)
[@@deriving sexp_of]

type member_modifier = [
    `Over of Token.t (* "override" *)
  | `Late of Token.t (* "lateinit" *)
]
[@@deriving sexp_of]

type visibility_modifier = [
    `Public of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Inte of Token.t (* "internal" *)
  | `Prot of Token.t (* "protected" *)
]
[@@deriving sexp_of]

type bin_literal = Token.t
[@@deriving sexp_of]

type pat_a2e2132 = Token.t (* pattern [0-9a-fA-F]{4} *)
[@@deriving sexp_of]

type integer_literal = Token.t
[@@deriving sexp_of]

type multiplicative_operator = [
    `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
]
[@@deriving sexp_of]

type escaped_identifier = Token.t (* pattern "\\\\[tbrn'\"\\\\$]" *)
[@@deriving sexp_of]

type type_projection_modifier = variance_modifier
[@@deriving sexp_of]

type shebang_line = (Token.t (* "#!" *) * pat_f630af3 (*tok*))
[@@deriving sexp_of]

type is_operator = [
    `Is of Token.t (* "is" *)
  | `Not_is of Token.t (* "!is" *)
]
[@@deriving sexp_of]

type lexical_identifier = [
    `Pat_ddcb2a5 of pat_ddcb2a5 (*tok*)
  | `Pat_b9a3713 of pat_b9a3713 (*tok*)
]
[@@deriving sexp_of]

type member_access_operator = [
    `DOT of Token.t (* "." *)
  | `Safe_nav of Token.t (* "?." *)
  | `COLONCOLON of Token.t (* "::" *)
]
[@@deriving sexp_of]

type multi_line_string_content = [
    `Multi_line_str_text of multi_line_str_text (*tok*)
  | `DQUOT of Token.t (* "\"" *)
]
[@@deriving sexp_of]

type modifier = [
    `Class_modi of class_modifier
  | `Member_modi of member_modifier
  | `Visi_modi of visibility_modifier
  | `Func_modi of function_modifier
  | `Prop_modi of Token.t (* "const" *)
  | `Inhe_modi of inheritance_modifier
  | `Param_modi of parameter_modifier
  | `Plat_modi of platform_modifier
]
[@@deriving sexp_of]

type uni_character_literal = (
    Token.t (* "\\" *) * Token.t (* "u" *) * pat_a2e2132 (*tok*)
)
[@@deriving sexp_of]

type anon_choice_int_lit_9015f32 = [
    `Int_lit of integer_literal (*tok*)
  | `Hex_lit of hex_literal (*tok*)
  | `Bin_lit of bin_literal (*tok*)
]
[@@deriving sexp_of]

type type_projection_modifiers =
  type_projection_modifier list (* one or more *)
[@@deriving sexp_of]

type simple_identifier = [
    `Lexi_id of lexical_identifier
  | `Pat_831065d of pat_831065d (*tok*)
]
[@@deriving sexp_of]

type return_at = (Token.t (* "return@" *) * lexical_identifier)
[@@deriving sexp_of]

type escape_seq = [
    `Uni_char_lit of uni_character_literal
  | `Esca_id of escaped_identifier (*tok*)
]
[@@deriving sexp_of]

type line_str_escaped_char = [
    `Esca_id of escaped_identifier (*tok*)
  | `Uni_char_lit of uni_character_literal
]
[@@deriving sexp_of]

type import_alias = (Token.t (* "as" *) * simple_identifier)
[@@deriving sexp_of]

type directly_assignable_expression = [ `Simple_id of simple_identifier ]
[@@deriving sexp_of]

type identifier = (
    simple_identifier
  * (Token.t (* "." *) * simple_identifier) list (* zero or more *)
)
[@@deriving sexp_of]

type line_string_content = [
    `Line_str_text of line_str_text (*tok*)
  | `Line_str_esca_char of line_str_escaped_char
]
[@@deriving sexp_of]

type import_header = (
    Token.t (* "import" *)
  * identifier
  * [ `DOTSTAR of Token.t (* ".*" *) | `Import_alias of import_alias ] option
  * semi (*tok*)
)
[@@deriving sexp_of]

type package_header = (Token.t (* "package" *) * identifier * semi (*tok*))
[@@deriving sexp_of]

type literal_constant = [
    `Bool_lit of boolean_literal
  | `Int_lit of integer_literal (*tok*)
  | `Hex_lit of hex_literal (*tok*)
  | `Bin_lit of bin_literal (*tok*)
  | `Char_lit of (
        Token.t (* "'" *)
      * [ `Esc_seq of escape_seq | `Pat_b294348 of pat_b294348 (*tok*) ]
      * Token.t (* "'" *)
    )
  | `Real_lit of real_literal (*tok*)
  | `Null of Token.t (* "null" *)
  | `Long_lit of (anon_choice_int_lit_9015f32 * Token.t (* "L" *))
  | `Unsi_lit of (
        anon_choice_int_lit_9015f32
      * pat_c793459 (*tok*)
      * Token.t (* "L" *) option
    )
]
[@@deriving sexp_of]

type annotated_lambda = lambda_literal

and annotation = [
    `Single_anno of (
        Token.t (* "@" *)
      * use_site_target option
      * unescaped_annotation
    )
  | `Multi_anno of (
        Token.t (* "@" *)
      * use_site_target option
      * Token.t (* "[" *)
      * unescaped_annotation list (* one or more *)
      * Token.t (* "]" *)
    )
]

and anon_choice_param_b77c1d8 = [ `Param of parameter | `Type of type_ ]

and assignment = [
  `Dire_assi_exp_assign_and_op_exp of (
      directly_assignable_expression * assignment_and_operator * expression
  )
]

and binary_expression = [
    `Mult_exp of (expression * multiplicative_operator * expression)
  | `Addi_exp of (expression * additive_operator * expression)
  | `Range_exp of (expression * Token.t (* ".." *) * expression)
  | `Infix_exp of (expression * simple_identifier * expression)
  | `Elvis_exp of (expression * Token.t (* "?:" *) * expression)
  | `Check_exp of (
        expression
      * [ `In_op of in_operator | `Is_op of is_operator ]
      * expression
    )
  | `Comp_exp of (expression * comparison_operator * expression)
  | `Equa_exp of (expression * equality_operator * expression)
  | `Conj_exp of (expression * Token.t (* "&&" *) * expression)
  | `Disj_exp of (expression * Token.t (* "||" *) * expression)
]

and block = (Token.t (* "{" *) * statements option * Token.t (* "}" *))

and call_suffix = [
    `Opt_value_args_anno_lambda of (
        value_arguments option
      * annotated_lambda
    )
  | `Value_args of value_arguments
]

and catch_block = (
    Token.t (* "catch" *)
  * Token.t (* "(" *)
  * annotation list (* zero or more *)
  * simple_identifier
  * Token.t (* ":" *)
  * type_
  * Token.t (* ")" *)
  * block
)

and class_body = (
    Token.t (* "{" *)
  * class_member_declarations option
  * Token.t (* "}" *)
)

and class_declaration = [
    `Opt_modifs_choice_class_simple_id_opt_type_params_opt_prim_cons_opt_COLON_dele_specis_opt_type_consts_opt_class_body of (
        modifiers option
      * [
            `Class of Token.t (* "class" *)
          | `Inte of Token.t (* "interface" *)
        ]
      * simple_identifier
      * type_parameters option
      * primary_constructor option
      * (Token.t (* ":" *) * delegation_specifiers) option
      * type_constraints option
      * class_body option
    )
  | `Opt_modifs_enum_class_simple_id_opt_type_params_opt_prim_cons_opt_COLON_dele_specis_opt_type_consts_opt_enum_class_body of (
        modifiers option
      * Token.t (* "enum" *)
      * Token.t (* "class" *)
      * simple_identifier
      * type_parameters option
      * primary_constructor option
      * (Token.t (* ":" *) * delegation_specifiers) option
      * type_constraints option
      * enum_class_body option
    )
]

and class_member_declaration = [
    `Decl of declaration
  | `Comp_obj of (
        modifiers option
      * Token.t (* "companion" *)
      * Token.t (* "object" *)
      * simple_identifier option
      * (Token.t (* ":" *) * delegation_specifiers) option
      * class_body option
    )
  | `Anon_init of (Token.t (* "init" *) * block)
  | `Seco_cons of (
        modifiers option
      * Token.t (* "constructor" *)
      * function_value_parameters
      * (Token.t (* ":" *) * constructor_delegation_call) option
      * block option
    )
]

and class_member_declarations =
  (class_member_declaration * semis (*tok*)) list (* one or more *)

and class_parameter = (
    modifiers option
  * anon_choice_val_2833752 option
  * simple_identifier
  * Token.t (* ":" *)
  * type_
  * (Token.t (* "=" *) * expression) option
)

and class_parameters = (
    Token.t (* "(" *)
  * (
        class_parameter
      * (Token.t (* "," *) * class_parameter) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and constructor_delegation_call = (
    [ `This of Token.t (* "this" *) | `Super of Token.t (* "super" *) ]
  * value_arguments
)

and constructor_invocation = (user_type * value_arguments)

and control_structure_body = [ `Blk of block | `Stmt of statement ]

and declaration = [
    `Class_decl of class_declaration
  | `Obj_decl of (
        modifiers option
      * Token.t (* "object" *)
      * simple_identifier
      * (Token.t (* ":" *) * delegation_specifiers) option
      * class_body option
    )
  | `Func_decl of (
        modifiers option
      * type_parameters option
      * Token.t (* "fun" *)
      * simple_identifier
      * function_value_parameters
      * (Token.t (* ":" *) * type_) option
      * type_constraints option
      * function_body option
    )
  | `Prop_decl of (
        modifiers option
      * anon_choice_val_2833752
      * type_parameters option
      * variable_declaration
      * type_constraints option
      * [
            `EQ_exp of (Token.t (* "=" *) * expression)
          | `Prop_dele of property_delegate
        ]
          option
      * [ `Opt_getter of getter option | `Opt_setter of setter option ]
    )
  | `Type_alias of (
        Token.t (* "typealias" *) * simple_identifier * Token.t (* "=" *)
      * type_
    )
]

and delegation_specifier = [
    `Cons_invo of constructor_invocation
  | `Expl_dele of (
        [ `User_type of user_type | `Func_type of function_type ]
      * Token.t (* "by" *)
      * expression
    )
  | `User_type of user_type
  | `Func_type of function_type
]

and delegation_specifiers = (
    delegation_specifier
  * (Token.t (* "," *) * delegation_specifier) list (* zero or more *)
)

and enum_class_body = (
    Token.t (* "{" *)
  * enum_entries option
  * (Token.t (* ";" *) * class_member_declarations option) option
  * Token.t (* "}" *)
)

and enum_entries = (
    enum_entry
  * (Token.t (* "," *) * enum_entry) list (* zero or more *)
  * Token.t (* "," *) option
)

and enum_entry = (
    modifiers option
  * simple_identifier
  * value_arguments option
  * class_body option
)

and expression = [
    `Choice_un_exp of [
        `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Prim_exp of primary_expression
    ]
  | `Ellips of Token.t (* "..." *)
]

and finally_block = (Token.t (* "finally" *) * block)

and function_body = [
    `Blk of block
  | `EQ_exp of (Token.t (* "=" *) * expression)
]

and function_literal = [
    `Lambda_lit of lambda_literal
  | `Anon_func of (
        Token.t (* "fun" *)
      * (
            simple_user_type
          * (Token.t (* "." *) * simple_user_type) list (* zero or more *)
          * Token.t (* "." *)
        )
          option
      * Token.t (* "(" *)
      * Token.t (* ")" *)
      * function_body option
    )
]

and function_type = (
    (simple_user_type * Token.t (* "." *)) option
  * function_type_parameters
  * Token.t (* "->" *)
  * type_
)

and function_type_parameters = (
    Token.t (* "(" *)
  * (
        anon_choice_param_b77c1d8
      * (Token.t (* "," *) * anon_choice_param_b77c1d8)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and function_value_parameter = (
    parameter_modifiers option
  * parameter
  * (Token.t (* "=" *) * expression) option
)

and function_value_parameters = (
    Token.t (* "(" *)
  * (
        function_value_parameter
      * (Token.t (* "," *) * function_value_parameter)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and getter = (
    Token.t (* "get" *)
  * (
        Token.t (* "(" *)
      * Token.t (* ")" *)
      * (Token.t (* ":" *) * type_) option
      * function_body
    )
      option
)

and indexing_suffix = (
    Token.t (* "[" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "]" *)
)

and interpolation = [
    `DOLLARLCURL_exp_RCURL of (
        Token.t (* "${" *) * expression * Token.t (* "}" *)
    )
  | `DOLLAR_simple_id of (Token.t (* "$" *) * simple_identifier)
]

and jump_expression = [
    `Throw_exp of (Token.t (* "throw" *) * expression)
  | `Choice_ret_opt_exp of (
        [ `Ret of Token.t (* "return" *) | `Ret_at of return_at ]
      * expression option
    )
  | `Cont of Token.t (* "continue" *)
  | `Cont_at of (Token.t (* "continue@" *) * lexical_identifier)
  | `Brk of Token.t (* "break" *)
  | `Brk_at of (Token.t (* "break@" *) * lexical_identifier)
]

and lambda_literal = (
    Token.t (* "{" *)
  * (lambda_parameters option * Token.t (* "->" *)) option
  * statements option
  * Token.t (* "}" *)
)

and lambda_parameter = [ `Var_decl of variable_declaration ]

and lambda_parameters = (
    lambda_parameter
  * (Token.t (* "," *) * lambda_parameter) list (* zero or more *)
)

and loop_statement = [
    `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * annotation list (* zero or more *)
      * lambda_parameter
      * Token.t (* "in" *)
      * expression
      * Token.t (* ")" *)
      * control_structure_body option
    )
  | `While_stmt of (
        Token.t (* "while" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * [
            `SEMI of Token.t (* ";" *)
          | `Cont_stru_body of control_structure_body
        ]
    )
  | `Do_while_stmt of (
        Token.t (* "do" *)
      * control_structure_body option
      * Token.t (* "while" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
    )
]

and modifiers = [
    `Anno of annotation
  | `Rep1_modi of modifier list (* one or more *)
]

and navigation_suffix = (
    member_access_operator
  * [
        `Simple_id of simple_identifier
      | `Paren_exp of parenthesized_expression
      | `Class of Token.t (* "class" *)
    ]
)

and nullable_type = (
    [ `Type_ref of type_reference | `Paren_type of parenthesized_type ]
  * Token.t (* "?" *) list (* one or more *)
)

and parameter = (simple_identifier * Token.t (* ":" *) * type_)

and parameter_modifiers = [
    `Anno of annotation
  | `Rep1_param_modi of parameter_modifier list (* one or more *)
]

and parameter_with_optional_type = (
    parameter_modifiers option
  * simple_identifier
  * (Token.t (* ":" *) * type_) option
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and parenthesized_type = (Token.t (* "(" *) * type_ * Token.t (* ")" *))

and primary_constructor = (
    (modifiers option * Token.t (* "constructor" *)) option
  * class_parameters
)

and primary_expression = [
    `Paren_exp of parenthesized_expression
  | `Simple_id of simple_identifier
  | `Lit_cst of literal_constant
  | `Str_lit of string_literal
  | `Call_ref of (
        simple_identifier option
      * Token.t (* "::" *)
      * [ `Simple_id of simple_identifier | `Class of Token.t (* "class" *) ]
    )
  | `Func_lit of function_literal
  | `Obj_lit of (
        Token.t (* "object" *)
      * (Token.t (* ":" *) * delegation_specifiers) option
      * class_body
    )
  | `Coll_lit of (
        Token.t (* "[" *)
      * expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* "]" *)
    )
  | `This_exp of Token.t (* "this" *)
  | `Super_exp of Token.t (* "super" *)
  | `If_exp of (
        Token.t (* "if" *)
      * Token.t (* "(" *)
      * expression
      * Token.t (* ")" *)
      * [
            `Cont_stru_body of control_structure_body
          | `SEMI of Token.t (* ";" *)
          | `Opt_cont_stru_body_opt_SEMI_else_choice_cont_stru_body of (
                control_structure_body option
              * Token.t (* ";" *) option
              * Token.t (* "else" *)
              * [
                    `Cont_stru_body of control_structure_body
                  | `SEMI of Token.t (* ";" *)
                ]
            )
        ]
    )
  | `When_exp of (
        Token.t (* "when" *)
      * when_subject option
      * Token.t (* "{" *)
      * when_entry list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `Try_exp of (
        Token.t (* "try" *)
      * block
      * [
            `Rep1_catch_blk_opt_fina_blk of (
                catch_block list (* one or more *)
              * finally_block option
            )
          | `Fina_blk of finally_block
        ]
    )
  | `Jump_exp of jump_expression
]

and property_delegate = (Token.t (* "by" *) * expression)

and range_test = (in_operator * expression)

and setter = (
    Token.t (* "set" *)
  * (
        Token.t (* "(" *)
      * parameter_with_optional_type
      * Token.t (* ")" *)
      * (Token.t (* ":" *) * type_) option
      * function_body
    )
      option
)

and simple_user_type = (simple_identifier * type_arguments option)

and statement = [
    `Decl of declaration
  | `Rep_choice_label_choice_assign of (
        [ `Label of label (*tok*) | `Anno of annotation ]
          list (* zero or more *)
      * [
            `Assign of assignment
          | `Loop_stmt of loop_statement
          | `Exp of expression
        ]
    )
]

and statements = (
    statement
  * (semis (*tok*) * statement) list (* zero or more *)
  * semis (*tok*) option
)

and string_literal = [
    `Line_str_lit of (
        Token.t (* "\"" *)
      * [
            `Line_str_content of line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Multi_line_str_lit of (
        Token.t (* "\"\"\"" *)
      * [
            `Multi_line_str_content of multi_line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"\"\"" *)
    )
]

and type_ = (
    type_modifiers option
  * [
        `Paren_type of parenthesized_type
      | `Null_type of nullable_type
      | `Type_ref of type_reference
      | `Func_type of function_type
    ]
)

and type_arguments = (
    Token.t (* "<" *)
  * type_projection
  * (Token.t (* "," *) * type_projection) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_constraint = (
    annotation list (* zero or more *)
  * simple_identifier
  * Token.t (* ":" *)
  * type_
)

and type_constraints = (
    Token.t (* "where" *)
  * type_constraint
  * (Token.t (* "," *) * type_constraint) list (* zero or more *)
)

and type_modifier = [
    `Anno of annotation
  | `Susp of Token.t (* "suspend" *)
]

and type_modifiers = type_modifier list (* one or more *)

and type_parameter = (
    type_parameter_modifiers option
  * simple_identifier
  * (Token.t (* ":" *) * type_) option
)

and type_parameter_modifier = [
    `Reif_modi of Token.t (* "reified" *)
  | `Vari_modi of type_projection_modifier
  | `Anno of annotation
]

and type_parameter_modifiers = type_parameter_modifier list (* one or more *)

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_projection = [
    `Opt_type_proj_modifs_type of (type_projection_modifiers option * type_)
  | `STAR of Token.t (* "*" *)
]

and type_reference = [
    `User_type of user_type
  | `Dyna of Token.t (* "dynamic" *)
]

and type_test = (is_operator * expression)

and unary_expression = [
    `Post_exp of (expression * postfix_unary_operator)
  | `Call_exp of (expression * call_suffix)
  | `Inde_exp of (expression * indexing_suffix)
  | `Navi_exp of (expression * navigation_suffix)
  | `Prefix_exp of (
        [
            `Anno of annotation
          | `Label of label (*tok*)
          | `Prefix_un_op of prefix_unary_operator
        ]
      * expression
    )
  | `As_exp of (expression * as_operator * type_)
  | `Spread_exp of (Token.t (* "*" *) * expression)
]

and unescaped_annotation = [
    `Cons_invo of constructor_invocation
  | `User_type of user_type
]

and user_type = (
    simple_user_type
  * (Token.t (* "." *) * simple_user_type) list (* zero or more *)
)

and value_argument = (
    annotation option
  * (simple_identifier * Token.t (* "=" *)) option
  * Token.t (* "*" *) option
  * expression
)

and value_arguments = (
    Token.t (* "(" *)
  * (
        value_argument
      * (Token.t (* "," *) * value_argument) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and variable_declaration = (
    simple_identifier
  * (Token.t (* ":" *) * type_) option
)

and when_condition = (expression * range_test * type_test)

and when_entry = (
    [
        `When_cond_rep_COMMA_when_cond of (
            when_condition
          * (Token.t (* "," *) * when_condition) list (* zero or more *)
        )
      | `Else of Token.t (* "else" *)
    ]
  * Token.t (* "->" *)
  * control_structure_body
  * semi (*tok*) option
)

and when_subject = (
    Token.t (* "(" *)
  * (
        annotation list (* zero or more *)
      * Token.t (* "val" *)
      * variable_declaration
      * Token.t (* "=" *)
    )
      option
  * expression
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type parenthesized_user_type = (
    Token.t (* "(" *)
  * [ `User_type of user_type | `Paren_user_type of parenthesized_user_type ]
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type file_annotation = (
    Token.t (* "@" *)
  * Token.t (* "file" *)
  * Token.t (* ":" *)
  * [
        `LBRACK_rep1_unes_anno_RBRACK of (
            Token.t (* "[" *)
          * unescaped_annotation list (* one or more *)
          * Token.t (* "]" *)
        )
      | `Unes_anno of unescaped_annotation
    ]
)
[@@deriving sexp_of]

type source_file = [
    `Opt_sheb_line_opt_rep1_file_anno_semi_opt_pack_header_rep_import_header_rep_stmt_semi of (
        shebang_line option
      * (file_annotation list (* one or more *) * semi (*tok*)) option
      * package_header option
      * import_header list (* zero or more *)
      * (statement * semi (*tok*)) list (* zero or more *)
    )
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
]
[@@deriving sexp_of]

type ellipsis (* inlined *) = Token.t (* "..." *)
[@@deriving sexp_of]

type property_modifier (* inlined *) = Token.t (* "const" *)
[@@deriving sexp_of]

type quest (* inlined *) = Token.t (* "?" *)
[@@deriving sexp_of]

type this_expression (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type not_is (* inlined *) = Token.t (* "!is" *)
[@@deriving sexp_of]

type safe_nav (* inlined *) = Token.t (* "?." *)
[@@deriving sexp_of]

type super_expression (* inlined *) = Token.t (* "super" *)
[@@deriving sexp_of]

type not_in (* inlined *) = Token.t (* "!in" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type reification_modifier (* inlined *) = Token.t (* "reified" *)
[@@deriving sexp_of]

type continue_at (* inlined *) = (
    Token.t (* "continue@" *) * lexical_identifier
)
[@@deriving sexp_of]

type this_at (* inlined *) = (Token.t (* "this@" *) * lexical_identifier)
[@@deriving sexp_of]

type super_at (* inlined *) = (Token.t (* "super@" *) * lexical_identifier)
[@@deriving sexp_of]

type break_at (* inlined *) = (Token.t (* "break@" *) * lexical_identifier)
[@@deriving sexp_of]

type unsigned_literal (* inlined *) = (
    anon_choice_int_lit_9015f32
  * pat_c793459 (*tok*)
  * Token.t (* "L" *) option
)
[@@deriving sexp_of]

type long_literal (* inlined *) = (
    anon_choice_int_lit_9015f32 * Token.t (* "L" *)
)
[@@deriving sexp_of]

type callable_reference (* inlined *) = (
    simple_identifier option
  * Token.t (* "::" *)
  * [ `Simple_id of simple_identifier | `Class of Token.t (* "class" *) ]
)
[@@deriving sexp_of]

type character_literal (* inlined *) = (
    Token.t (* "'" *)
  * [ `Esc_seq of escape_seq | `Pat_b294348 of pat_b294348 (*tok*) ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type additive_expression (* inlined *) = (
    expression * additive_operator * expression
)
[@@deriving sexp_of]

type anonymous_function (* inlined *) = (
    Token.t (* "fun" *)
  * (
        simple_user_type
      * (Token.t (* "." *) * simple_user_type) list (* zero or more *)
      * Token.t (* "." *)
    )
      option
  * Token.t (* "(" *)
  * Token.t (* ")" *)
  * function_body option
)
[@@deriving sexp_of]

type anonymous_initializer (* inlined *) = (Token.t (* "init" *) * block)
[@@deriving sexp_of]

type as_expression (* inlined *) = (expression * as_operator * type_)
[@@deriving sexp_of]

type call_expression (* inlined *) = (expression * call_suffix)
[@@deriving sexp_of]

type check_expression (* inlined *) = (
    expression
  * [ `In_op of in_operator | `Is_op of is_operator ]
  * expression
)
[@@deriving sexp_of]

type collection_literal (* inlined *) = (
    Token.t (* "[" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type companion_object (* inlined *) = (
    modifiers option
  * Token.t (* "companion" *)
  * Token.t (* "object" *)
  * simple_identifier option
  * (Token.t (* ":" *) * delegation_specifiers) option
  * class_body option
)
[@@deriving sexp_of]

type comparison_expression (* inlined *) = (
    expression * comparison_operator * expression
)
[@@deriving sexp_of]

type conjunction_expression (* inlined *) = (
    expression * Token.t (* "&&" *) * expression
)
[@@deriving sexp_of]

type disjunction_expression (* inlined *) = (
    expression * Token.t (* "||" *) * expression
)
[@@deriving sexp_of]

type do_while_statement (* inlined *) = (
    Token.t (* "do" *)
  * control_structure_body option
  * Token.t (* "while" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type elvis_expression (* inlined *) = (
    expression * Token.t (* "?:" *) * expression
)
[@@deriving sexp_of]

type equality_expression (* inlined *) = (
    expression * equality_operator * expression
)
[@@deriving sexp_of]

type explicit_delegation (* inlined *) = (
    [ `User_type of user_type | `Func_type of function_type ]
  * Token.t (* "by" *)
  * expression
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * annotation list (* zero or more *)
  * lambda_parameter
  * Token.t (* "in" *)
  * expression
  * Token.t (* ")" *)
  * control_structure_body option
)
[@@deriving sexp_of]

type function_declaration (* inlined *) = (
    modifiers option
  * type_parameters option
  * Token.t (* "fun" *)
  * simple_identifier
  * function_value_parameters
  * (Token.t (* ":" *) * type_) option
  * type_constraints option
  * function_body option
)
[@@deriving sexp_of]

type if_expression (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * [
        `Cont_stru_body of control_structure_body
      | `SEMI of Token.t (* ";" *)
      | `Opt_cont_stru_body_opt_SEMI_else_choice_cont_stru_body of (
            control_structure_body option
          * Token.t (* ";" *) option
          * Token.t (* "else" *)
          * [
                `Cont_stru_body of control_structure_body
              | `SEMI of Token.t (* ";" *)
            ]
        )
    ]
)
[@@deriving sexp_of]

type indexing_expression (* inlined *) = (expression * indexing_suffix)
[@@deriving sexp_of]

type infix_expression (* inlined *) = (
    expression * simple_identifier * expression
)
[@@deriving sexp_of]

type line_string_expression (* inlined *) = (
    Token.t (* "${" *) * expression * Token.t (* "}" *)
)
[@@deriving sexp_of]

type line_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [ `Line_str_content of line_string_content | `Interp of interpolation ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type multi_annotation (* inlined *) = (
    Token.t (* "@" *)
  * use_site_target option
  * Token.t (* "[" *)
  * unescaped_annotation list (* one or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type multi_line_string_literal (* inlined *) = (
    Token.t (* "\"\"\"" *)
  * [
        `Multi_line_str_content of multi_line_string_content
      | `Interp of interpolation
    ]
      list (* zero or more *)
  * Token.t (* "\"\"\"" *)
)
[@@deriving sexp_of]

type multiplicative_expression (* inlined *) = (
    expression * multiplicative_operator * expression
)
[@@deriving sexp_of]

type navigation_expression (* inlined *) = (expression * navigation_suffix)
[@@deriving sexp_of]

type object_declaration (* inlined *) = (
    modifiers option
  * Token.t (* "object" *)
  * simple_identifier
  * (Token.t (* ":" *) * delegation_specifiers) option
  * class_body option
)
[@@deriving sexp_of]

type object_literal (* inlined *) = (
    Token.t (* "object" *)
  * (Token.t (* ":" *) * delegation_specifiers) option
  * class_body
)
[@@deriving sexp_of]

type postfix_expression (* inlined *) = (expression * postfix_unary_operator)
[@@deriving sexp_of]

type prefix_expression (* inlined *) = (
    [
        `Anno of annotation
      | `Label of label (*tok*)
      | `Prefix_un_op of prefix_unary_operator
    ]
  * expression
)
[@@deriving sexp_of]

type property_declaration (* inlined *) = (
    modifiers option
  * anon_choice_val_2833752
  * type_parameters option
  * variable_declaration
  * type_constraints option
  * [
        `EQ_exp of (Token.t (* "=" *) * expression)
      | `Prop_dele of property_delegate
    ]
      option
  * [ `Opt_getter of getter option | `Opt_setter of setter option ]
)
[@@deriving sexp_of]

type range_expression (* inlined *) = (
    expression * Token.t (* ".." *) * expression
)
[@@deriving sexp_of]

type secondary_constructor (* inlined *) = (
    modifiers option
  * Token.t (* "constructor" *)
  * function_value_parameters
  * (Token.t (* ":" *) * constructor_delegation_call) option
  * block option
)
[@@deriving sexp_of]

type single_annotation (* inlined *) = (
    Token.t (* "@" *)
  * use_site_target option
  * unescaped_annotation
)
[@@deriving sexp_of]

type spread_expression (* inlined *) = (Token.t (* "*" *) * expression)
[@@deriving sexp_of]

type try_expression (* inlined *) = (
    Token.t (* "try" *)
  * block
  * [
        `Rep1_catch_blk_opt_fina_blk of (
            catch_block list (* one or more *)
          * finally_block option
        )
      | `Fina_blk of finally_block
    ]
)
[@@deriving sexp_of]

type type_alias (* inlined *) = (
    Token.t (* "typealias" *) * simple_identifier * Token.t (* "=" *) * type_
)
[@@deriving sexp_of]

type when_expression (* inlined *) = (
    Token.t (* "when" *)
  * when_subject option
  * Token.t (* "{" *)
  * when_entry list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * [
        `SEMI of Token.t (* ";" *)
      | `Cont_stru_body of control_structure_body
    ]
)
[@@deriving sexp_of]

type parameters_with_optional_type (* inlined *) = (
    Token.t (* "(" *)
  * parameter_with_optional_type
  * (Token.t (* "," *) * parameter_with_optional_type)
      list (* zero or more *)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type top_level_object (* inlined *) = (declaration * semis (*tok*) option)
[@@deriving sexp_of]

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)
[@@deriving sexp_of]

type annotated_delegation_specifier (* inlined *) = (
    annotation list (* zero or more *)
  * delegation_specifier
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_source_file root
  |> Print_sexp.to_stdout
